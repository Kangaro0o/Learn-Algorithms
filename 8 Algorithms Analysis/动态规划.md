# 动态规划DP

动态规划（英语：Dynamic programming，简称 DP），通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。复杂问题不能分解成几个子问题，而分解成一系列子问题 ；

DP通常基于一个递推公式及一个(或多个)初始状态，当前子问题解由上一次子问题解推出。


动态规划算法的关键在于解决冗余，以空间换时间的技术，需要存储过程中的各种状态。可以看着是`分治算法`+`解决冗余`


动态规划算法也可以说是 `记住求过的解来节省时间`

【初始状态】→【决策1】→【决策2】→…→【决策n】→【结束状态】


### DP 应用场景

如果一个问题，可以把所有可能的答案穷举出来，并且穷举出来后，发现存在重叠子问题，就可以考虑使用动态规划。

使用动态规划算法的问题的特征是`子问题的重叠性`，`最优子结构` ，否则动态规划算法不具备优势。

动态规划的核心思想就是穷举求最值； 动态规划问题的一般形式就是`求最值`,动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多，比如说： 

* 最长递增子序列 （LIS Longest Increasing Subsequence）
* 最小编辑距离
* 0-1 背包问题 
* 凑零钱问题
* 股票问题
* 接雨水问题
* Fibonacci数列 
* 青蛙跳阶问题： 一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 10 级的台阶总共有多少种跳法。


```
# 青蛙跳阶问题
想跳到第10级台阶，要么是先跳到第9级，然后再跳1级台阶上去;要么是先跳到第8级，然后一次迈2级台阶上去。
同理，要想跳到第9级台阶，要么是先跳到第8级，然后再跳1级台阶上去;要么是先跳到第7级，然后一次迈2级台阶上去。
要想跳到第8级台阶，要么是先跳到第7级，然后再跳1级台阶上去;要么是先跳到第6级，然后一次迈2级台阶上去

即通用公式为: f(n) = f(n-1) + f(n-2)

那f(2) 或者 f(1) 等于多少呢？

当只有2级台阶时，有两种跳法，第一种是直接跳两级，第二种是先跳一级，然后再跳一级。即f(2) = 2;
当只有1级台阶时，只有一种跳法，即f（1）= 1；

```


### DP VS 分治法

与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。我们可以用一个表来记录所有已解的子问题的答案。



## DP 解题模板


#### 基本步骤

* 划分问题
* 状态
* 状态转移方程, 这一步最为困难
* 状态压缩



```
# 初始化 base case
dp[0][0][...] = base

# 进行状态转移
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)
```













